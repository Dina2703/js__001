<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ASync JS</title>
  </head>
  <body style="padding: 2rem">
    <h2>Asynchronous JS</h2>
    <h4>setTimeout() and setInterval()</h4>
    <p>
      Timers and Intervals are not part of JS itself. They are implemented by
      the browser and
      <span style="color: red">setTimeout() and setInterval()</span> are
      basically names give to that functionallity in JS
    </p>
    <h4>Callbacks</h4>

    <ul>
      <li>
        <strong>Callbacks </strong> are functions passed as arguments to others
        functions. The function which accepts a function as an argument or
        returns a function is called <strong>a higher order function</strong>.
      </li>
      <li>
        They can be <strong>synchronous </strong> if they execute immediatly or
        they can be <strong>asynchronous </strong> where they get executed after
        some time has passed, some event has occured or some data has been
        fetched
      </li>
      <li>
        The phenomenon which happens when we
        <em>nest multiple callbacks within a function </em> is called
        <strong> a callback hell</strong>. It makes the code very difficult to
        understand and maintain.
      </li>
      <li>
        An alternative and the recommend approach now is to use
        <strong>Promises</strong>
      </li>
    </ul>
    <div id="demo"></div>
    <button id="btn">click</button>

    <h4>Promises</h4>
    <p>
      A <strong>Promise</strong> is a proxy for a value not necessarily known
      when the promise is created. Technically promise is an object in JS
    </p>
    <p>A <strong>Promise</strong> can be in any of theses below stages:</p>
    <ul>
      <li><strong>Pending</strong> - waiting for result.</li>
      <li><strong>Fulfilled</strong> - operation completed successfully</li>
      <li><strong>Rejected</strong> - operation failed.</li>
    </ul>

    <h3>Why we use Promises?</h3>
    <p>
      <strong>Promises</strong> help us deal with asynchronous code in a far
      more simpler way compared to callbacks. <em>Callbakc hell</em> can be
      avoided with <strong>Promises</strong>.
    </p>
    <h3>How to work with <strong>Promises</strong>?</h3>
    <h5>3 steps:</h5>
    <ul>
      <li>How to create Promise?</li>
      <li>How to <em>fulfill or reject Promise?</em></li>
      <li>
        How to execute callback functions based on whether Promise is fulfilled
        or rejected? (success callback or failure callback)
      </li>
    </ul>

    <h3>How to create a Promise?</h3>
    we create an instance of a Promise using the <strong>new</strong> keyword
    with the <em>Promise constructure function.</em>
    <br />
    <code>const promise = new Promise()</code>
    <h3>How to fulfill or reject the Promise?</h3>
    <p>
      This Promise() constructure function accepts one function as its argument.
      So we pass in an arrow function, and this arrow function automatically
      receives 2 arguments: <strong>resolve</strong> and
      <strong>reject</strong>.
    </p>
    <h4>Resolve and reject are both functions.</h4>
    <p>
      <strong>Resolve</strong> is a function which when called changes the
      status of the <em>promise</em> from <em>pending to fulfilled</em>
    </p>
    <p>
      <strong>Reject</strong> is a function which when called changes the status
      of the <em>promise</em> from <em>pending to rejected</em>
    </p>
    <p>
      Both these functions are typically called after an
      <strong>async operation</strong>
    </p>
    <h5>Example with resolve() callback:</h5>
    <br />
    <code
      >const promise = new Promise((resolve, reject) => {
      <br />
      //some async operation
      <br />
      //change status from 'pending' to 'fulfilled'
      <br />
      resolve()
      <br />
      })</code
    >
    <h5>Example with resolve() callback:</h5>
    <code
      >const promise = new Promise((resolve, reject) => {
      <br />
      //some async operation
      <br />
      //change status from 'pending' to 'rejected'
      <br />
      reject()
      <br />
      })</code
    >
    <h3>How to execute callback functions based on the status change?</h3>
    <p style="color: red">Resolve scenario</p>

    <code>
      const promise = new Promise((resolve, reject) => {
      <br />
      setTimeout(() => {
      <br />
      //operation completed successfully
      <br />
      //change states from 'pending' to 'fulfilled'
      <br />
      resolve()
      <br />
      }, 5000)
      <br />
      })
    </code>

    <p style="color: red">Reject scenario</p>

    <code>
      const promise = new Promise((resolve, reject) => {
      <br />
      setTimeout(() => {
      <br />
      //operation failed
      <br />
      //change states from 'pending' to 'fulfilled'
      <br />
      reject()
      <br />
      }, 5000)
      <br />
      }) <br />
    </code>

    <h5>Success and failure callbacks</h5>

    <code>
      const onFullfillmentCallbackFn = (result) => {
      <br />
      //resolve was called
      <br />
      console.log(result)
      <br />
      console.log('set the data')
      <br />
      }
      <br />

      const onRejectionCallbackFn = (error) => {
      <br />
      //reject was called
      <br />
      console.log(error)
      <br />
      console.log('set error message') <br />
      }
    </code>
    <h3>then() and catch() methods</h3>

    <ul>
      <li>
        Promise status: pending to fulfilled?
        <span style="color: red">then() is executed</span>. The then() method
        automatically gets invoked.
      </li>
      <li>
        Promise status: pending to rejected?
        <span style="color: red">catch() is executed</span>. The catch() method
        automatically gets invoked.
      </li>
    </ul>
    <code style="color: red">
      promise.then(onFullfillmentCallbackFn)
      <br />
      promise.catch(onRejectionCallbackFn)
    </code>
    <h3>Summary for interview</h3>
    <ul>
      <li>Begin by explaining what is a Promise. Explain in your own words.</li>

      <li>How Promises are used for async operations in JS</li>
      <li>
        Give an analogy to a real world sceanrion and connect ir back to JS
      </li>
      <li>
        talk about the three states that a Promise can be. Pending, fulfilled
        and rejcted
      </li>
      <li>
        Talk about the resolve and reject functions and how they change the
        state of the Promise from pending to fulfilled pr pending to rejected.
      </li>
      <li>
        Finally, talk about the onFulfillment and onREject callback functions
        which let you decide what to run when a Promise is fulfilled or
        rejected.
      </li>
    </ul>

    <h3>Promise - Part 2</h3>
    <h4>Chaining Promises</h4>

    <p>
      Both <em>then()</em> and <em>catch()</em> can be chained.
      <br />
      <code>
        promise.then(onFulfillment)
        <br />
        promise.catch(onRejection)
      </code>
      <br /> 
      <p>can be re-writted:</p>
      <code>promise.then(onFulfillment).catch(onRejection)</code>
      <script src="script.js"></script>
    </p>

    <h3>Promise - Part 3</h3>
    <h4>Promise - static methods</h4>
    <h5 style="color: red;">Promise.all()</h5>
    <p>We can use <span style="color: red;">.all()</span> method to query multiple APIs and perform some actions but only after all the APIs have finished loading</p>
    <br>
    <code>
      const promise1 = Promise.resolve(3)
      <br>
      const promise2 = 42
      <br>
      const promise3 = new Promise((resolve, reject) => {
        <br>
        setTimeout(resolve, 100, 'foo')
        <br>
      }) <br>
      Promise.all([promise1, promise2, promise3]).then(value => {
        <br>
        console.log(value)
      }) //expected output: Array [3, 42, 'foo']
      
    </code>
    <br>
    <strong>Keep in mind,even if one promise gets rejected, promise.all() will reject with that error.</strong>
    <p>
      Summary  for the Promise.all()
    </p>
    <ul><li>
      The Promise.all() method takes an iterable of promises as an input and returns a single Promise that resolves to an array of the results of the input promises.
    </li>
  <li>
    Returned promise will resolve when all the input's promises have resolved, or if the input iterable contains no promises.
  </li>
<li>
  It rejects immediately if any of the input promises reject or the non-promises throw an error, and will rejcte with this first rejection message / error.
</li></ul>


<h5 style="color: red;">Promise.allSettled()</h5>
<p>Promise.allSettled() waits for all input promises to complete regardless of whether or not one of then is rejected. <br>(in contrast with Promise.all() - even if one promise gets rejected, promise.all() will reject with that error.)</p>
<br>
<code>
  const promise1 = Promise.resolve(3)
  <br>
  const promise2 = 42
  <br>
  const promise3 = new Promise((resolve, reject) => {
    <br>
    setTimeout(resolve, 100, 'foo')
    <br>
  }) <br>
  Promise.allSettled([promise1, promise2, promise3]).then(value => {
    <br>
    console.log(value)
  }) //expected output: Array [3, 42, 'foo']
  
</code>

<h5 style="color: red;">Promise.race()</h5>
<p>The Promise.race() method returns a promise that fulfills or rejects as soon as one of the input promises fulfills or rejects, with the value or reason from that promise</p>
<br>

  </body>

</html>
