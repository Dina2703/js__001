<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ASync JS</title>
  </head>
  <body style="padding: 2rem">
    <h2>Asynchronous JS</h2>
    <h4>setTimeout() and setInterval()</h4>
    <p>
      Timers and Intervals are not part of JS itself. They are implemented by
      the browser and
      <span style="color: red">setTimeout() and setInterval()</span> are
      basically names give to that functionallity in JS
    </p>
    <h4>Callbacks</h4>

    <ul>
      <li>
        <strong>Callbacks </strong> are functions passed as arguments to others
        functions. The function which accepts a function as an argument or
        returns a function is called <strong>a higher order function</strong>.
      </li>
      <li>
        They can be <strong>synchronous </strong> if they execute immediatly or
        they can be <strong>asynchronous </strong> where they get executed after
        some time has passed, some event has occured or some data has been
        fetched
      </li>
      <li>
        The phenomenon which happens when we
        <em>nest multiple callbacks within a function </em> is called
        <strong> a callback hell</strong>. It makes the code very difficult to
        understand and maintain.
      </li>
      <li>
        An alternative and the recommend approach now is to use
        <strong>Promises</strong>
      </li>
    </ul>
    <div id="demo"></div>
    <button id="btn">click</button>

    <h4>Promises</h4>
    <p>
      A <strong>Promise</strong> is a proxy for a value not necessarily known
      when the promise is created. Technically promise is an object in JS
    </p>
    <p>A <strong>Promise</strong> can be in any of theses below stages:</p>
    <ul>
      <li><strong>Pending</strong> - waiting for result.</li>
      <li><strong>Fulfilled</strong> - operation completed successfully</li>
      <li><strong>Rejected</strong> - operation failed.</li>
    </ul>

    <h3>Why we use Promises?</h3>
    <p>
      <strong>Promises</strong> help us deal with asynchronous code in a far
      more simpler way compared to callbacks. <em>Callbakc hell</em> can be
      avoided with <strong>Promises</strong>.
    </p>
    <h3>How to work with <strong>Promises</strong>?</h3>
    <h5>3 steps:</h5>
    <ul>
      <li>How to create Promise?</li>
      <li>How to <em>fulfill or reject Promise?</em></li>
      <li>
        How to execute callback functions based on whether Promise is fulfilled
        or rejected? (success callback or failure callback)
      </li>
    </ul>

    <h3>How to create a Promise?</h3>
    we create an instance of a Promise using the <strong>new</strong> keyword
    with the <em>Promise constructure function.</em>
    <br />
    <code>const promise = new Promise()</code>
    <h3>How to fulfill or reject the Promise?</h3>
    <p>
      This Promise() constructure function accepts one function as its argument.
      So we pass in an arrow function, and this arrow function automatically
      receives 2 arguments: <strong>resolve</strong> and
      <strong>reject</strong>.
    </p>
    <h4>Resolve and reject are both functions.</h4>
    <p>
      <strong>Resolve</strong> is a function which when called changes the
      status of the <em>promise</em> from <em>pending to fulfilled</em>
    </p>
    <p>
      <strong>Reject</strong> is a function which when called changes the status
      of the <em>promise</em> from <em>pending to rejected</em>
    </p>
    <p>
      Both these functions are typically called after an
      <strong>async operation</strong>
    </p>
    <h5>Example with resolve() callback:</h5>
    <br />
    <code
      >const promise = new Promise((resolve, reject) => {
      <br />
      //some async operation
      <br />
      //change status from 'pending' to 'fulfilled'
      <br />
      resolve()
      <br />
      })</code
    >
    <h5>Example with resolve() callback:</h5>
    <code
      >const promise = new Promise((resolve, reject) => {
      <br />
      //some async operation
      <br />
      //change status from 'pending' to 'rejected'
      <br />
      reject()
      <br />
      })</code
    >
    <h3>How to execute callback functions based on the status change?</h3>
    <p style="color: red">Resolve scenario</p>

    <code>
      const promise = new Promise((resolve, reject) => {
      <br />
      setTimeout(() => {
      <br />
      //operation completed successfully
      <br />
      //change states from 'pending' to 'fulfilled'
      <br />
      resolve()
      <br />
      }, 5000)
      <br />
      })
    </code>

    <p style="color: red">Reject scenario</p>

    <code>
      const promise = new Promise((resolve, reject) => {
      <br />
      setTimeout(() => {
      <br />
      //operation failed
      <br />
      //change states from 'pending' to 'fulfilled'
      <br />
      reject()
      <br />
      }, 5000)
      <br />
      }) <br />
    </code>

    <h5>Success and failure callbacks</h5>

    <code>
      const onFullfillmentCallbackFn = (result) => {
      <br />
      //resolve was called
      <br />
      console.log(result)
      <br />
      console.log('set the data')
      <br />
      }
      <br />

      const onRejectionCallbackFn = (error) => {
      <br />
      //reject was called
      <br />
      console.log(error)
      <br />
      console.log('set error message') <br />
      }
    </code>
    <h3>the() and catch() methods</h3>

    <ul>
      <li>
        Promise status: pending to fulfilled?
        <span style="color: red">then() is executed</span>. The then() method
        automatically gets invoked.
      </li>
      <li>
        Promise status: pending to rejected?
        <span style="color: red">catch() is executed</span>. The catch() method
        automatically gets invoked.
      </li>
    </ul>
    <code style="color: red">
      promise.then(onFullfillmentCallbackFn)
      <br />
      promise.catch(onRejectionCallbackFn)
    </code>
    <h3>Summary for interview</h3>
    <ul>
      <li>Begin by explaining what is a Promise. Explain in your own words.</li>

      <li>How Promises are used for async operations in JS</li>
      <li>
        Give an analogy to a real world sceanrion and connect ir back to JS
      </li>
      <li>
        talk about the three states that a Promise can be. Pending, fulfilled
        and rejcted
      </li>
      <li>
        Talk about the resolve and reject functions and how they change the
        state of the Promise from pending to fulfilled pr pending to rejected.
      </li>
      <li>
        Finally, talk about the onFulfillment and onREject callback functions
        which let you decide what to run when a Promise is fulfilled or
        rejected.
      </li>
    </ul>
    <script src="script.js"></script>
  </body>
</html>
