<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ASync JS</title>
  </head>
  <body>
    <h2>Asynchronous JS</h2>
    <h4>setTimeout() and setInterval()</h4>
    <p>
      Timers and Intervals are not part of JS itself. They are implemented by
      the browser and
      <span style="color: red">setTimeout() and setInterval()</span> are
      basically names give to that functionallity in JS
    </p>
    <h4>Callbacks</h4>

    <ul>
      <li>
        <strong>Callbacks </strong> are functions passed as arguments to others
        functions. The function which accepts a function as an argument or
        returns a function is called <strong>a higher order function</strong>.
      </li>
      <li>
        They can be <strong>synchronous </strong> if they execute immediatly or
        they can be <strong>asynchronous </strong> where they get executed after
        some time has passed, some event has occured or some data has been
        fetched
      </li>
      <li>
        The phenomenon which happens when we
        <em>nest multiple callbacks within a function </em> is called
        <strong> a callback hell</strong>. It makes the code very difficult to
        understand and maintain.
      </li>
      <li>
        An alternative and the recommend approach now is to use
        <strong>Promises</strong>
      </li>
    </ul>
    <div id="demo"></div>
    <button id="btn">click</button>

    <h4>Promises</h4>
    <p>
      A <strong>Promise</strong> is a proxy for a value not necessarily known
      when the promise is created. Technically promise is an object in JS
    </p>
    <p>A <strong>Promise</strong> can be in any of theses below stages:</p>
    <ul>
      <li><strong>Pending</strong> - waiting for result.</li>
      <li><strong>Fulfilled</strong> - operation completed successfully</li>
      <li><strong>Rejected</strong> - operation failed.</li>
    </ul>

    <h3>Why we use Promises?</h3>
    <p>
      <strong>Promises</strong> help us deal with asynchronous code in a far
      more simpler way compared to callbacks. <em>Callbakc hell</em> can be
      avoided with <strong>Promises</strong>.
    </p>
    <h3>How to work with <strong>Promises</strong>?</h3>
    <h5>3 steps:</h5>
    <ul>
      <li>How to create Promise?</li>
      <li>How to <em>fulfill or reject Promise?</em></li>
      <li>
        How to execute callback functions based on whether Promise is fulfilled
        or rejected? (success callback or failure callback)
      </li>
    </ul>

    <h3>How to create a Promise?</h3>
    we create an instance of a Promise using the <strong>new</strong> keyword
    with the <em>Promise constructure function.</em>
    <br />
    <code>const promise = new Promise()</code>
    <h3>How to fulfill or reject the Promise?</h3>
    <p>
      This Promise() constructure function accepts one function as its argument.
      So we pass in an arrow function, and this arrow function automatically
      receives 2 arguments: <strong>resolve</strong> and
      <strong>reject</strong>.
    </p>
    <h4>Resolve and reject are both functions.</h4>
    <p>
      <strong>Resolve</strong> is a function which when called changes the
      status of the <em>promise</em> from <em>pending to fulfilled</em>
    </p>
    <p>
      <strong>Reject</strong> is a function which when called changes the status
      of the <em>promise</em> from <em>pending to rejected</em>
    </p>
    <p>
      Both these functions are typically called after an
      <strong>async operation</strong>
    </p>
    <h5>Example with resolve() callback:</h5>
    <br />
    <code
      >const promise = new Promise((resolve, reject) => {
      <br />
      //some async operation
      <br />
      //change status from 'pending' to 'fulfilled'
      <br />
      resolve()
      <br />
      })</code
    >
    <h5>Example with resolve() callback:</h5>
    <code
      >const promise = new Promise((resolve, reject) => {
      <br />
      //some async operation
      <br />
      //change status from 'pending' to 'rejected'
      <br />
      reject()
      <br />
      })</code
    >

    <script src="script.js"></script>
  </body>
</html>
